// import { Entity, Column, ManyToOne } from 'typeorm'; 
// import { Base } from './common/base';
// import { ContactPerson } from './contactPerson';
// import { StandardSkillStandardLevel } from './standardSkillStandardLevel';

// @Entity("contact_person_standard_skill_standard_levels") 
// export class ContactPersonStandardSkillStandardLevel extends Base { 

//    @ManyToOne(() => ContactPerson)
//    @Column({ name: "contact_person_id" })
//    contactPerson: ContactPerson;

//    @ManyToOne(() => StandardSkillStandardLevel)
//    @Column({ name: "standard_skill_standard_level_id" })
//    standardSkillStandardLevel: StandardSkillStandardLevel;

// }




DELIMITER //
CREATE  PROCEDURE dorepeat(startdate DATE, enddate DATE)
  BEGIN
    SET @x = STR_TO_DATE(startdate,'%e-%m-%Y');
    REPEAT 
      SET @x = ADDDATE(@x, INTERVAL 1 MONTH); 
      SELECT @x month, SUM(resource_selling_rate* actual_hours) FROM profit_view 
      GROUP BY month;
    UNTIL @x >= STR_TO_DATE(enddate,'%e-%m-%Y') 
    END REPEAT;
  END
//
DELIMITER ;


CREATE  PROCEDURE dorepeat()
  BEGIN
  SELECT SUM(resource_selling_rate* actual_hours) FROM profit_view ;
  END;





  DELIMITER //
  CREATE PROCEDURE dorepeat(startDate DATE, endDate DATE)
    BEGIN
        SET @x = STR_TO_DATE(startDate,'%Y-%m-%d');
      SET @y = STR_TO_DATE(endDate,'%Y-%m-%d');
      REPEAT 
          SELECT 
              project_type,
              project_amount,
              (CASE WHEN project_type = 2 
                THEN 
                  SUM( resource_buying_rate * actual_hours ) 
                ELSE 
                  0 
                END )
              month_total_buy, 
  
              (CASE WHEN project_type = 2 
                THEN 
                    SUM( resource_selling_rate * actual_hours ) 
                ELSE 
                  project_schedule_segments.amount 
                END )
              month_total_sell, 
  
              SUM(actual_hours) actual_hours, 
              #(CASE WHEN project_type = 2 
                #THEN 
                  #DATE_FORMAT(STR_TO_DATE(entry_date,'%e-%m-%Y'), '%b %y') 
                #ELSE 
                  #DATE_FORMAT(project_schedule_segments.start_date, '%b %y') 
                #END) 
                DATE_FORMAT( @x, '%b %y') month
  
              FROM profit_view
                LEFT JOIN project_schedules ON
                  profit_view.project_id = project_schedules.project_id
                    LEFT JOIN project_schedule_segments  ON 
                      project_schedules.id = project_schedule_segments.schedule_id 
  
              WHERE ( project_status = 'P' OR project_status = 'C' ) 
              AND project_start <= STR_TO_DATE('01-07-2022' ,'%Y-%m-%d') 
              AND project_end >= STR_TO_DATE('30-06-2023' ,'%Y-%m-%d') 
              AND project_schedules.deleted_at IS NULL 
              AND project_schedule_segments.deleted_at IS NULL 
              GROUP BY project_type, month;
              SET @x =DATE_ADD(@x, INTERVAL 1 MONTH);
              UNTIL @x <= @y
            END REPEAT;
    END
    //






    CREATE PROCEDURE dorepeat(startDate DATE, endDate DATE)
  BEGIN
  	SET @x = 0;
    SET @y = STR_TO_DATE(endDate,'%Y-%m-%d');
    REPEAT 
        SELECT 
            project_type,
            project_amount,
            (CASE WHEN project_type = 2 
              THEN 
                SUM( resource_buying_rate * actual_hours ) 
              ELSE 
                0 
              END )
            month_total_buy, 

            (CASE WHEN project_type = 2 
              THEN 
                  SUM( resource_selling_rate * actual_hours ) 
              ELSE 
                project_schedule_segments.amount 
              END )
            month_total_sell, 

            SUM(actual_hours) actual_hours, 
            (CASE WHEN project_type = 2 
              THEN 
                DATE_FORMAT(STR_TO_DATE(entry_date,'%e-%m-%Y'), '%b %y') 
              ELSE 
                DATE_FORMAT(project_schedule_segments.start_date, '%b %y') 
              END) 
              #DATE_FORMAT( @x, '%b %y') month

            FROM profit_view
              LEFT JOIN project_schedules ON
                profit_view.project_id = project_schedules.project_id
                  LEFT JOIN project_schedule_segments  ON 
                    project_schedules.id = project_schedule_segments.schedule_id 

            WHERE ( project_status = 'P' OR project_status = 'C' ) 
            AND project_start <= STR_TO_DATE('01-07-2022' ,'%Y-%m-%d') 
            AND project_end >= STR_TO_DATE('30-06-2023' ,'%Y-%m-%d') 
            AND project_schedules.deleted_at IS NULL 
            AND project_schedule_segments.deleted_at IS NULL 
            GROUP BY project_type, month;
            SET @x = @x+1;
            UNTIL @x <= @y
          END REPEAT;
  END;;



  `Select o_r.start_date res_startDate, o_r.end_date res_endDate, ec.start_date con_startDate, ec.end_date con_endDate, 
      (ora.buying_rate *( (ec.no_of_hours /5) * (ora.effort_rate /100) ) ) forecastBuyRateDaily, 
      (ora.selling_rate *( (ec.no_of_hours /5) * (ora.effort_rate /100) ) ) forecastSellRateDaily
      FROM opportunities o 
        JOIN opportunity_resources o_r ON 
          o_r.opportunity_id = o.id 
                JOIN opportunity_resource_allocations ora ON 
                    ora.opportunity_resource_id = o_r.id 
                    JOIN contact_person_organizations cpo ON 
                        cpo.contact_person_id = ora.contact_person_id 
                        JOIN employees e ON 
                        e.contact_person_organization_id = cpo.id
                        JOIN employment_contracts ec ON
                          ec.employee_id = e.id
      WHERE o.id = ${projectId} AND ora.is_marked_as_selected = 1 AND ec.start_date <= STR_TO_DATE('${fiscalYear.end}' ,'%e-%m-%Y') 
      AND (ec.end_date IS NULL ||  ec.end_date >= STR_TO_DATE('${fiscalYear.actual}' ,'%e-%m-%Y')) 
      AND o_r.start_date <= STR_TO_DATE('${fiscalYear.end}' ,'%e-%m-%Y') AND ec.deleted_at IS NULL AND ora.deleted_at IS NULL`



    DELIMITER //
CREATE PROCEDURE dorepeat(startDate DATE, endDate DATE)
  BEGIN
    DECLARE SS DATE DEFAULT STR_TO_DATE(startDate,'%Y-%m-%d');
    DECLARE S DATE DEFAULT STR_TO_DATE(startDate,'%Y-%m-%d');
    DECLARE E DATE DEFAULT STR_TO_DATE(endDate,'%Y-%m-%d');
    -- SET S = STR_TO_DATE(startDate,'%Y-%m-%d');
    -- SET E = STR_TO_DATE(endDate,'%Y-%m-%d');
    
      SELECT 
      
          SUM(forcaste_buy_rate) forcaste_buy_rates,
          SUM(forcaste_sell_rate) forcaste_sell_rates,
        (SELECT  WHILE (S <= E) DO
          ((5 * (DATEDIFF(E, S) DIV 7) + 
          MID('0123444401233334012222340111123400001234000123440', 
            7 * WEEKDAY(S) + 
            WEEKDAY(E) + 1, 
            1)+1) - 
          (SELECT COUNT(*) FROM calendar_holidays 
            WHERE (WEEKDAY(calendar_holidays.date) < 5)
            AND (calendar_holidays.date BETWEEN  S  AND E)
          )) working_days,
          DATE_FORMAT(S, '%b %y') month;
          SET S = DATE_ADD(S, INTERVAL 1 MONTH);
        END WHILE;
        ) as holidays

      FROM forecaste_view
      WHERE ( project_status = 'P' OR project_status = 'C' )
            AND resource_contract_start <= SS
            AND (resource_contract_end IS NULL OR  resource_contract_end >= CURRENT_DATE())
            AND (resource_start BETWEEN  SS AND E);
  END
//
DELIMITER ;


DELIMITER //

CREATE PROCEDURE loop_date(startDate DATE, endDate DATE)
BEGIN
    DECLARE dateStart DATETIME DEFAULT startDate;
    DECLARE dateEnd DATETIME DEFAULT endDate;
    
    WHILE (dateStart < '2020-01-01 00:00:00') DO
        INSERT INTO my_table(time_key) VALUES (dateStart);
        SET dateStart = dateStart + INTERVAL 3 HOUR;
    END WHILE;
END //

DELIMITER ;



SELECT COUNT(*) holidays,
 (5 * (DATEDIFF('2022-10-31', '2022-10-01') DIV 7) + 
    MID('0123444401233334012222340111123400001234000123440', 
      7 * WEEKDAY('2022-10-01') + 
      WEEKDAY('2022-10-31') + 1, 
      1)+1) number_of_days
FROM calendar_holidays  
      WHERE (calendar_holidays.date BETWEEN  STR_TO_DATE('2022-10-01' ,'%Y-%m-%d')  AND STR_TO_DATE('2022-10-31' ,'%Y-%m-%d'))
      AND (WEEKDAY(calendar_holidays.date) < 5);

    SELECT actual.* , forecaste.* 
      FROM (SELECT 
        profit_view.project_id,
        project_type,
        (CASE WHEN project_type = 2 
          THEN 
              SUM( resource_selling_rate * actual_hours ) 
          ELSE 
            project_schedule_segments.amount 
          END )
        month_total_sell, 
        
        (CASE WHEN project_type = 2 
          THEN 
            DATE_FORMAT(STR_TO_DATE(entry_date,'%e-%m-%Y'), '%b %y') 
          ELSE 
            DATE_FORMAT(project_schedule_segments.start_date, '%b %y') 
          END) 
        month
      
        FROM profit_view
          LEFT JOIN project_schedules ON
            profit_view.project_id = project_schedules.project_id
              LEFT JOIN project_schedule_segments  ON 
                project_schedules.id = project_schedule_segments.schedule_id 
                
        WHERE ( project_status = 'P' OR project_status = 'C' ) 
        
        AND project_start <= STR_TO_DATE('2023-30-06' ,'%Y-%m-%d') 
        AND project_end >= STR_TO_DATE('2022-07-01' ,'%Y-%m-%d') 
        AND project_schedules.deleted_at IS NULL 
        AND project_schedule_segments.deleted_at IS NULL 

        GROUP BY project_id, month) as actual

        LEFT JOIN 
        (
          SELECT 
          project_type,
          resource_start,
          resource_end,
          resource_contract_start,
          resource_contract_end,
          SUM(forcaste_buy_rate) forcaste_buy_rates,
          SUM(forcaste_sell_rate) forcaste_sell_rates

      FROM forecaste_view
      WHERE ( project_status = 'P' OR project_status = 'C' )
            AND resource_contract_start <= STR_TO_DATE('2023-30-06' ,'%Y-%m-%d') 
            AND (resource_contract_end IS NULL OR  resource_contract_end >= CURRENT_DATE())
            AND (resource_start BETWEEN  STR_TO_DATE('2023-30-06' ,'%Y-%m-%d')  AND STR_TO_DATE('2023-30-06' ,'%Y-%m-%d')  )
        ) as forecaste

      ON forecaste.project_type = actual.project_type;


      


SELECT 
  month_total_buy,
  project_type,
  month,
  (CASE WHEN project_type = 2 
    THEN 
      SUM(time_base.month_total_sell)
    ELSE 
      SUM(project_schedule_segments.amount)
  END ) month_total_sell
   
      FROM (
        SELECT 
          SUM(cost_rate)  month_total_buy, 
          SUM(revenue_rate) month_total_sell, 
          project_type, 
          resource_employee_id,
          project_id,
          milestone_id,
          calendar_date,
          DATE_FORMAT(STR_TO_DATE(calendar_view_filtered.calendar_date,'%Y-%m-%d'), '%b %y') month

        From (
          SELECT * FROM calendar_view
            WHERE (calendar_view.calendar_date BETWEEN '2022-07-01' AND '2023-06-30')
          ) as calendar_view_filtered

          LEFT JOIN revenue_cost_view
          ON ((calendar_view_filtered.calendar_date BETWEEN DATE_FORMAT(resource_start,'%Y-%m-%d') AND DATE_FORMAT(resource_end,'%Y-%m-%d')) AND
            (calendar_view_filtered.calendar_date BETWEEN 
              DATE_FORMAT(resource_contract_start,'%Y-%m-%d') AND 
              DATE_FORMAT(IFNULL(resource_contract_end, '2049-06-30'),'%Y-%m-%d'))
            )

        WHERE is_holidays = 0 AND is_weekday = 1

        GROUP BY project_type, month, project_id 
      ) as time_base

    LEFT JOIN  project_schedules 
      ON time_base.project_id = project_schedules.project_id 
      LEFT JOIN project_schedule_segments
      ON project_schedule_segments.schedule_id = project_schedules.id
      AND (time_base.calendar_date BETWEEN DATE_FORMAT(project_schedule_segments.start_date,'%Y-%m-%d') AND 
      DATE_FORMAT(project_schedule_segments.end_date,'%Y-%m-%d'))

GROUP BY project_type, month;

  SELECT  
    month_total_buy, 
    time_base.project_type,
    month,
    (CASE WHEN project_type = 2 
      THEN 
          time_base.month_total_sell
      ELSE 
        SUM(project_schedule_segments.amount)
      END ) month_total_sell
    FROM (SELECT 
      SUM(cost_rate)  month_total_buy, 
      SUM(revenue_rate) month_total_sell, 
      project_type, 
      calendar_date,
      DATE_FORMAT(STR_TO_DATE(calendar_view_filtered.calendar_date,'%Y-%m-%d'), '%b %y') month

        From (
            SELECT * FROM calendar_view
              WHERE (calendar_view.calendar_date BETWEEN '2022-07-01' AND '2023-06-30')
            ) as calendar_view_filtered

            LEFT JOIN revenue_cost_view
            ON (
              (calendar_view_filtered.calendar_date BETWEEN 
                DATE_FORMAT(resource_start,'%Y-%m-%d') AND 
                DATE_FORMAT(resource_end,'%Y-%m-%d')
              ) AND
              (calendar_view_filtered.calendar_date BETWEEN 
                DATE_FORMAT(resource_contract_start,'%Y-%m-%d') AND 
                DATE_FORMAT(IFNULL(resource_contract_end, '2049-06-30'),'%Y-%m-%d')
              )
            )

        WHERE is_holidays = 0 AND is_weekday = 1

        GROUP BY project_type, month ) as time_base

    LEFT JOIN opportunities
      ON opportunities.type = project_type
    LEFT JOIN  project_schedules 
      ON project_schedules.project_id = opportunities.id 
      LEFT JOIN project_schedule_segments
      ON project_schedule_segments.schedule_id = project_schedules.id
      AND (time_base.calendar_date BETWEEN DATE_FORMAT(project_schedule_segments.start_date,'%Y-%m-%d') AND 
      DATE_FORMAT(project_schedule_segments.end_date,'%Y-%m-%d'))

GROUP BY project_type, month;


-- FORECAST REVENUE FINAL
  SELECT 
  month_total_buy,
  time_base.project_type,
  month,
  (CASE WHEN project_type = 2 
    THEN 
        time_base.month_total_sell
    ELSE 
      SUM(project_schedule_segments.amount)
    END ) month_total_sell
  FROM (SELECT 
      SUM(cost_rate)  month_total_buy, 
      SUM(revenue_rate) month_total_sell, 
      project_type, 
      calendar_date,
      DATE_FORMAT(STR_TO_DATE(calendar_view_filtered.calendar_date,'%Y-%m-%d'), '%b %y') month

        From (
            SELECT * FROM calendar_view
              WHERE (calendar_view.calendar_date BETWEEN '2022-07-01' AND '2023-06-30')
            ) as calendar_view_filtered

            LEFT JOIN revenue_cost_view
            ON (
              (calendar_view_filtered.calendar_date BETWEEN 
                DATE_FORMAT(resource_start,'%Y-%m-%d') AND 
                DATE_FORMAT(resource_end,'%Y-%m-%d')
              ) AND
              (calendar_view_filtered.calendar_date BETWEEN 
                DATE_FORMAT(resource_contract_start,'%Y-%m-%d') AND 
                DATE_FORMAT(IFNULL(resource_contract_end, '2049-06-30'),'%Y-%m-%d')
              )
            )

        WHERE is_holidays = 0 AND is_weekday = 1

        GROUP BY project_type, month ) as time_base

    LEFT JOIN opportunities
      ON opportunities.type = project_type
    LEFT JOIN  project_schedules 
      ON project_schedules.project_id = opportunities.id 
      LEFT JOIN project_schedule_segments
      ON project_schedule_segments.schedule_id = project_schedules.id
      AND (time_base.calendar_date BETWEEN DATE_FORMAT(project_schedule_segments.start_date,'%Y-%m-%d') AND 
      DATE_FORMAT(project_schedule_segments.end_date,'%Y-%m-%d'))
    WHERE project_schedule_segments.deleted_at IS NULL AND project_schedules.deleted_at IS NULL
GROUP BY project_type, month  

-- SQL CASUAL WILL RUN ON EVERY DAY LOOP
  SELECT 
      SUM(IFNULL(salary * (resource_contract_hours/resource_contract_days_per_week),0)) casual_salaries,
      SUM(IFNULL(salary * (resource_contract_hours / resource_contract_days_per_week),0) * (SELECT
          SUM(global_variable_values.value/100) 
          FROM global_variable_labels
          JOIN global_variable_values ON global_variable_labels.id = global_variable_values.global_variable_id
      WHERE
          global_variable_labels.name = 'Superannuation'
          AND calendar_view_filtered.calendar_date BETWEEN global_variable_values.start_date
          AND global_variable_values.end_date)) casual_superannuation,
      DATE_FORMAT(STR_TO_DATE(calendar_view_filtered.calendar_date,'%Y-%m-%d'), '%b %y') month 
      From (
        SELECT * FROM calendar_view
          WHERE (calendar_view.calendar_date BETWEEN '2022-07-01' AND '2023-06-30') 
        ) as calendar_view_filtered

        LEFT JOIN (
              SELECT * FROM revenue_cost_view 
              WHERE employment_type = 1
          ) as casual_employee
        ON ((calendar_view_filtered.calendar_date BETWEEN  
            DATE_FORMAT(resource_contract_start,'%Y-%m-%d') AND  
            DATE_FORMAT(IFNULL(resource_contract_end, '2049-06-30'),'%Y-%m-%d')
          )
        )
    WHERE is_holidays = 0 AND is_weekday = 1 
GROUP BY month;


-- SQL perminant WILL RUN ON EVERY DAY MONTHLY
  SELECT 
    SUM(salary * (ABS(boh_percent - 100)/100)) permanent_salaries ,-- to seperate boh percent for salaries
    SUM(salary * (ABS(boh_percent - 100)/100) * (SELECT
      SUM(global_variable_values.value/100) 
        FROM global_variable_labels
        JOIN global_variable_values ON global_variable_labels.id = global_variable_values.global_variable_id
      WHERE
        global_variable_labels.name = 'Superannuation'
        AND calendar_view_filtered.calendar_date BETWEEN global_variable_values.start_date
        AND global_variable_values.end_date)) permanent_superannuation,
    DATE_FORMAT(STR_TO_DATE(calendar_view_filtered.calendar_date,'%Y-%m-%d'), '%b %y') month -- month wise salary checking contracts end 
      From ( 
        SELECT calendar_date FROM calendar_view
          WHERE (calendar_view.calendar_date BETWEEN '2022-07-01' AND '2023-06-30') -- checking for only one fiscal year 
          GROUP BY calendar_view.month -- group by to get only a date for month
        ) as calendar_view_filtered

        LEFT JOIN (
          SELECT * FROM revenue_cost_view 
          WHERE employment_type != 1
        ) as casual_employee -- group by to get only ONE date for month  to check contracts running dates on every month
        ON ((calendar_view_filtered.calendar_date BETWEEN 
            DATE_FORMAT(resource_contract_start,'%Y-%m-%d') AND -- JOIN ONLY ON CONTRACT TO AVOID REPEATED ALLOCATIONs
            DATE_FORMAT(IFNULL(resource_contract_end, '2049-06-30'),'%Y-%m-%d')
          )
        )
GROUP BY month;

-- SQL new on test permanent_salaries
  SELECT month, SUM(salary) permanent_salaries, SUM(superannuation) permanent_superannuation
    FROM (SELECT
      SUM((salary / 12) * (ABS(boh_percent - 100) / 100)) salary,
      -- to seperate boh percent for salaries
      SUM((salary / 12) * (ABS(boh_percent - 100) / 100) * (
          SELECT
          SUM(global_variable_values.value / 100)
          FROM
          global_variable_labels
          JOIN global_variable_values ON global_variable_labels.id = global_variable_values.global_variable_id
          WHERE
          global_variable_labels.name = 'Superannuation'
          AND calendar_view_filtered.calendar_date BETWEEN global_variable_values.start_date
          AND global_variable_values.end_date
      )) superannuation,
      DATE_FORMAT( STR_TO_DATE(calendar_view_filtered.calendar_date, '%Y-%m-%d'), '%b %y' ) month -- month wise salary checking contracts end 
      From (SELECT calendar_date
              FROM calendar_view
              WHERE
              (
                  calendar_view.calendar_date BETWEEN '${fiscalYearStart}' --'2022-07-01'
                  AND '${fiscalYearEnd}' --'2022-07-31'
              ) -- checking for only one fiscal year 
          GROUP BY calendar_view.month -- group by to get only a date for month
          ) as calendar_view_filtered
      LEFT JOIN ( SELECT *
          FROM revenue_cost_view
          WHERE employment_type != 1
      ) as casual_employee -- group by to get only ONE date for month  to check contracts running dates on every month
      ON ( (
          calendar_view_filtered.calendar_date BETWEEN DATE_FORMAT(resource_contract_start, '%Y-%m-%d')
          AND -- JOIN ONLY ON CONTRACT TO AVOID REPEATED ALLOCATIONs
          DATE_FORMAT( IFNULL(resource_contract_end, '2049-06-30'), '%Y-%m-%d' ) 
      ))
      GROUP BY
        resource_contract_start,
        resource_contract_end,
        resource_employee_id,
        month
    ) as costing
GROUP BY month;

-- SQL new on test casual_salaries
  SELECT SUM(casual_salaries) casual_salaries, SUM(casual_superannuation) casual_superannuation, month
  FROM (SELECT 
    salary * (resource_contract_hours/resource_contract_days_per_week) casual_salaries,
    salary * (resource_contract_hours / resource_contract_days_per_week) * (SELECT
        SUM(global_variable_values.value/100) 
        FROM global_variable_labels
        JOIN global_variable_values ON global_variable_labels.id = global_variable_values.global_variable_id
    WHERE
        global_variable_labels.name = 'Superannuation'
        AND calendar_view_filtered.calendar_date BETWEEN global_variable_values.start_date
        AND global_variable_values.end_date) casual_superannuation,
    DATE_FORMAT(STR_TO_DATE(calendar_view_filtered.calendar_date,'%Y-%m-%d'), '%b %y') month 
    From (
      SELECT * FROM calendar_view                 --'2022-07-01'           '2022-06-31'
        WHERE (calendar_view.calendar_date BETWEEN '${fiscalYearStart}' AND '${fiscalYearEnd}') 
      ) as calendar_view_filtered
      LEFT JOIN (
            SELECT * FROM revenue_cost_view 
            WHERE employment_type = 1
        ) as casual_employee
      ON ((calendar_view_filtered.calendar_date BETWEEN  
          DATE_FORMAT(resource_contract_start,'%Y-%m-%d') AND  
          DATE_FORMAT(IFNULL(resource_contract_end, '2049-06-30'),'%Y-%m-%d')
        )
      )
  WHERE is_holidays = 0 AND is_weekday = 1 
  GROUP BY
      resource_contract_start,
      resource_contract_end,
      resource_employee_id,
      month
  ) as costing
GROUP BY month;


-- SQL new on test doh_salaries
SELECT month, SUM(salary) doh_salaries, SUM(superannuation) doh_superannuation
  FROM
    (SELECT 
      salary/12 * (boh_percent)/100 salary ,-- to seperate boh percent for salaries
      salary/12 * (boh_percent)/100 * (SELECT
        SUM(global_variable_values.value/100) 
          FROM global_variable_labels
          JOIN global_variable_values ON global_variable_labels.id = global_variable_values.global_variable_id
        WHERE
          global_variable_labels.name = 'Superannuation'
          AND calendar_view_filtered.calendar_date BETWEEN global_variable_values.start_date
          AND global_variable_values.end_date
    ) superannuation,
    DATE_FORMAT(STR_TO_DATE(calendar_view_filtered.calendar_date,'%Y-%m-%d'), '%b %y') month -- month wise salary checking contracts end 
      From ( 
        SELECT calendar_date FROM calendar_view       --'2022-07-01'              '2022-06-31'
          WHERE (calendar_view.calendar_date BETWEEN  '${fiscalYearStart}' AND '${fiscalYearEnd}') -- checking for only one fiscal year 
          GROUP BY calendar_view.month -- group by to get only a date for month
        ) as calendar_view_filtered

        LEFT JOIN (
          SELECT * FROM revenue_cost_view 
          WHERE employment_type != 1
        ) as casual_employee -- group by to get only ONE date for month  to check contracts running dates on every month
        ON ((calendar_view_filtered.calendar_date BETWEEN 
            DATE_FORMAT(resource_contract_start,'%Y-%m-%d') AND -- JOIN ONLY ON CONTRACT TO AVOID REPEATED ALLOCATIONs
            DATE_FORMAT(IFNULL(resource_contract_end, '2049-06-30'),'%Y-%m-%d')
          ))
    GROUP BY
      resource_contract_start,
      resource_contract_end,
      resource_employee_id,
      month
    ) as costing
GROUP BY month;

-- SQL casual_actual_salaries
SELECT 
    SUM(salary * actual_hours) casual_salaries,
    SUM(casual_superannuation * actual_hours) casual_superannuation,
    DATE_FORMAT(entry_date, '%b %y') month
  ROM ( 
    SELECT
        actual_hours,
        STR_TO_DATE(entry_date,'%e-%m-%Y') entry_date,
        revenue_cost_view.resource_employee_id,
        resource_contract_start,
        resource_contract_end,
        salary,
        salary * (SELECT
          SUM(global_variable_values.value/100) 
          FROM global_variable_labels
          JOIN global_variable_values ON global_variable_labels.id = global_variable_values.global_variable_id
        WHERE
          global_variable_labels.name = 'Superannuation'
          AND STR_TO_DATE(profit_view.entry_date,'%e-%m-%Y') BETWEEN global_variable_values.start_date
          AND global_variable_values.end_date) casual_superannuation
    FROM
        revenue_cost_view
        LEFT JOIN profit_view ON (
            revenue_cost_view.resource_employee_id = profit_view.resource_employee_id
        AND STR_TO_DATE(profit_view.entry_date,'%e-%m-%Y') BETWEEN '2022-07-01' AND  '2023-06-30' -- need to remove from here
            AND                                              -- '${fiscalYearStart}' AND  '${acutalMonthEnd}'
            (STR_TO_DATE(profit_view.entry_date,'%e-%m-%Y') BETWEEN  
            DATE_FORMAT(revenue_cost_view.resource_contract_start,'%Y-%m-%d') AND  
            DATE_FORMAT(IFNULL(revenue_cost_view.resource_contract_end, '2049-06-30'),'%Y-%m-%d')
            )
        )
    WHERE
        revenue_cost_view.employment_type = 1
        AND (
            revenue_cost_view.project_status = 'P'
            OR revenue_cost_view.project_status = 'C'
            )

  ) as casual_time_entries
GROUP BY month;

-- SQL INCOME income_tax
SELECT 
    income_tax.value/100 income_tax_rate,
    DATE_FORMAT( STR_TO_DATE(calendar_view_filtered.calendar_date, '%Y-%m-%d'), '%b %y' ) month
  FROM 
  (SELECT *  
  FROM calendar_view 
  WHERE( calendar_view.calendar_date BETWEEN '2022-07-01' -- '2022-07-01' 
              AND '2023-06-30'  -- '2023-06-30'  
      ) -- checking for only one fiscal year )
  ) as calendar_view_filtered
  LEFT JOIN (
      SELECT gvv.start_date, gvv.end_date, gvv.value from global_variable_labels gvl
          JOIN global_variable_values gvv on gvv.global_variable_id = gvl.id
      WHERE gvl.name = "income_tax"        
  ) as income_tax
  ON  (
      calendar_view_filtered.calendar_date BETWEEN 
          DATE_FORMAT(income_tax.start_date, '%Y-%m-%d')
              AND 
          DATE_FORMAT( IFNULL(income_tax.end_date, '2049-06-30'), '%Y-%m-%d' )
  )

GROUP BY month

-- SQL INCOME income_tax 2
SELECT 
    SUM(salary * actual_hours) casual_salaries,
    SUM(salary * (
        SELECT
            SUM(global_variable_values.value/100) 
            FROM global_variable_labels
            JOIN global_variable_values ON global_variable_labels.id = global_variable_values.global_variable_id
        WHERE
            global_variable_labels.name = 'Superannuation'
            AND timers.entry_date BETWEEN global_variable_values.start_date
            AND global_variable_values.end_date)  * actual_hours) casual_superannuation,
    DATE_FORMAT(entry_date, '%b %y') month
  FROM 
    (SELECT
        resource_employee_id,
        resource_contract_start,
        resource_contract_end,
        salary
    FROM
        revenue_cost_view 
    WHERE
        employment_type = 1
        AND (
            project_status = 'P'
            OR project_status = 'C'
        )
    )as revenue_cost_views
    LEFT JOIN (
        SELECT 
            resource_employee_id,
            actual_hours,
            STR_TO_DATE(entry_date,'%e-%m-%Y') entry_date
        FROM profit_view
        WHERE STR_TO_DATE(entry_date,'%e-%m-%Y') BETWEEN '2022-07-01' AND  '2023-06-30' -- need to remove from here
    ) as timers ON (
        revenue_cost_views.resource_employee_id = timers.resource_employee_id AND
        (timers.entry_date BETWEEN  
            DATE_FORMAT(revenue_cost_views.resource_contract_start,'%Y-%m-%d') AND  
            DATE_FORMAT(IFNULL(revenue_cost_views.resource_contract_end, '2049-06-30'),'%Y-%m-%d')
        )
    )
GROUP BY month;

